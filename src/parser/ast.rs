// Re-export for use in evaluator.
pub use super::expressions::RegexLiteral;

// Object constructor, represented by tuples of (key, value)
pub type Object = Vec<(Ast, Ast)>;

// Sort terms, representend by expresions and a bool indicating descending/ascending
pub type SortTerms = Vec<(Ast, bool)>;

#[derive(Debug, Clone)]
pub enum UnaryOp {
    Minus(Box<Ast>),
    ArrayConstructor(Vec<Ast>),
    ObjectConstructor(Object),
}

#[derive(Debug, PartialEq, Clone)]
pub enum BinaryOp {
    Add,
    Subtract,
    Multiply,
    Divide,
    Modulus,
    Equal,
    NotEqual,
    LessThan,
    GreaterThan,
    LessThanEqual,
    GreaterThanEqual,
    Concat,
    And,
    Or,
    In,
    Map,
    Range,
    FocusBind,
    IndexBind,
    Predicate,
    Apply,
    Bind,
}

impl std::fmt::Display for BinaryOp {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.write_str(match *self {
            BinaryOp::Add => "+",
            BinaryOp::Subtract => "-",
            BinaryOp::Multiply => "*",
            BinaryOp::Divide => "/",
            BinaryOp::Modulus => "%",
            BinaryOp::Equal => "=",
            BinaryOp::NotEqual => "!=",
            BinaryOp::LessThan => "<",
            BinaryOp::GreaterThan => ">",
            BinaryOp::LessThanEqual => "<=",
            BinaryOp::GreaterThanEqual => ">=",
            BinaryOp::Concat => "&",
            BinaryOp::And => "and",
            BinaryOp::Or => "or",
            BinaryOp::In => "in",
            BinaryOp::Map => ".",
            BinaryOp::Range => "..",
            BinaryOp::FocusBind => "@",
            BinaryOp::IndexBind => "#",
            BinaryOp::Predicate => "[]",
            BinaryOp::Apply => "~>",
            BinaryOp::Bind => ":=",
        })
    }
}

#[derive(Debug, Clone)]
pub enum AstKind {
    Empty,
    Null,
    Bool(bool),
    String(String),
    Number(f64),
    Regex(Box<RegexLiteral>),
    Name(String),
    Var(String),
    Unary(UnaryOp),
    Binary(BinaryOp, Box<Ast>, Box<Ast>),
    GroupBy(Box<Ast>, Object),
    OrderBy(Box<Ast>, Vec<(Ast, bool)>),
    Block(Vec<Ast>),
    Wildcard,
    Descendent,
    Parent,
    Function {
        name: String,
        proc: Box<Ast>,
        args: Vec<Ast>,
        is_partial: bool,
    },
    PartialArg,
    Lambda {
        name: String,
        args: Vec<Ast>,
        body: Box<Ast>,
        thunk: bool,
    },
    Ternary {
        cond: Box<Ast>,
        truthy: Box<Ast>,
        falsy: Option<Box<Ast>>,
    },
    Transform {
        pattern: Box<Ast>,
        update: Box<Ast>,
        delete: Option<Box<Ast>>,
    },

    // Generated by AST post-processing
    Path(Vec<Ast>),
    Filter(Box<Ast>),
    Sort(SortTerms),
    Index(String),
}

#[derive(Debug, Clone)]
pub struct Ast {
    pub kind: AstKind,

    /// The index in the original source that introduced this node
    pub char_index: usize,

    pub keep_array: bool,
    pub cons_array: bool,
    pub keep_singleton_array: bool,

    /// An optional group by expression, represented as an object.
    pub group_by: Option<(usize, Object)>,

    /// An optional list of predicates.
    pub predicates: Option<Vec<Ast>>,

    /// An optional list of evaluation stages, for example this specifies the filtering and
    /// indexing for various expressions.
    pub stages: Option<Vec<Ast>>,

    /// Set on a step to indicate that it produces tuple bindings for things like index and focus
    /// binds, and parent resolution.
    pub tuple: bool,

    /// A variable to bind the index of a step to
    pub index: Option<String>,

    // A variable to bind the context of a step to
    pub focus: Option<String>,
}

impl Default for Ast {
    fn default() -> Ast {
        Ast::new(AstKind::Empty, Default::default())
    }
}

impl Ast {
    pub fn new(kind: AstKind, char_index: usize) -> Self {
        Self {
            kind,
            char_index,
            keep_array: false,
            cons_array: false,
            keep_singleton_array: false,
            group_by: None,
            predicates: None,
            stages: None,
            tuple: false,
            index: None,
            focus: None,
        }
    }

    /// General-purpose traversal function that visits all nodes in the AST.
    /// The visitor function is called for each node and can choose to continue
    /// traversal or stop early by returning true/false.
    pub fn traverse<F>(&self, visitor: &mut F) -> bool
    where
        F: FnMut(&Ast) -> bool,
    {
        // Visit the current node first
        if !visitor(self) {
            return false;
        }

        // Then traverse child nodes
        match &self.kind {
            AstKind::Empty
            | AstKind::Null
            | AstKind::Bool(_)
            | AstKind::String(_)
            | AstKind::Number(_)
            | AstKind::Regex(_)
            | AstKind::Name(_)
            | AstKind::Var(_)
            | AstKind::Wildcard
            | AstKind::Descendent
            | AstKind::Parent
            | AstKind::PartialArg
            | AstKind::Index(_) => {} // No children to traverse

            AstKind::Unary(unary_op) => match unary_op {
                UnaryOp::Minus(ast) => {
                    if !ast.traverse(visitor) {
                        return false;
                    }
                }
                UnaryOp::ArrayConstructor(exprs) => {
                    for expr in exprs {
                        if !expr.traverse(visitor) {
                            return false;
                        }
                    }
                }
                UnaryOp::ObjectConstructor(object) => {
                    for (key, value) in object {
                        if !key.traverse(visitor) || !value.traverse(visitor) {
                            return false;
                        }
                    }
                }
            },

            AstKind::Binary(_, lhs, rhs) => {
                if !lhs.traverse(visitor) || !rhs.traverse(visitor) {
                    return false;
                }
            }

            AstKind::GroupBy(lhs, object) => {
                if !lhs.traverse(visitor) {
                    return false;
                }
                for (key, value) in object {
                    if !key.traverse(visitor) || !value.traverse(visitor) {
                        return false;
                    }
                }
            }

            AstKind::OrderBy(lhs, sort_terms) => {
                if !lhs.traverse(visitor) {
                    return false;
                }
                for (ast, _) in sort_terms {
                    if !ast.traverse(visitor) {
                        return false;
                    }
                }
            }

            AstKind::Block(exprs) => {
                for expr in exprs {
                    if !expr.traverse(visitor) {
                        return false;
                    }
                }
            }

            AstKind::Function { proc, args, .. } => {
                if !proc.traverse(visitor) {
                    return false;
                }
                for arg in args {
                    if !arg.traverse(visitor) {
                        return false;
                    }
                }
            }

            AstKind::Lambda { args, body, .. } => {
                for arg in args {
                    if !arg.traverse(visitor) {
                        return false;
                    }
                }
                if !body.traverse(visitor) {
                    return false;
                }
            }

            AstKind::Ternary {
                cond,
                truthy,
                falsy,
            } => {
                if !cond.traverse(visitor) || !truthy.traverse(visitor) {
                    return false;
                }
                if let Some(falsy_ast) = falsy {
                    if !falsy_ast.traverse(visitor) {
                        return false;
                    }
                }
            }

            AstKind::Transform {
                pattern,
                update,
                delete,
            } => {
                if !pattern.traverse(visitor) || !update.traverse(visitor) {
                    return false;
                }
                if let Some(delete_ast) = delete {
                    if !delete_ast.traverse(visitor) {
                        return false;
                    }
                }
            }

            AstKind::Path(steps) => {
                for step in steps {
                    if !step.traverse(visitor) {
                        return false;
                    }
                }
            }

            AstKind::Filter(ast) => {
                if !ast.traverse(visitor) {
                    return false;
                }
            }

            AstKind::Sort(sort_terms) => {
                for (ast, _) in sort_terms {
                    if !ast.traverse(visitor) {
                        return false;
                    }
                }
            }
        }

        // Traverse optional fields
        if let Some((_, object)) = &self.group_by {
            for (key, value) in object {
                if !key.traverse(visitor) || !value.traverse(visitor) {
                    return false;
                }
            }
        }

        if let Some(predicates) = &self.predicates {
            for pred in predicates {
                if !pred.traverse(visitor) {
                    return false;
                }
            }
        }

        if let Some(stages) = &self.stages {
            for stage in stages {
                if !stage.traverse(visitor) {
                    return false;
                }
            }
        }

        true
    }
}
